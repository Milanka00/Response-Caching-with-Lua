static_resources:
  listeners:
    - name: listener_0
      address:
        socket_address:
          address: 0.0.0.0
          port_value: 8080
      filter_chains:
        - filters:
            - name: envoy.filters.network.http_connection_manager
              typed_config:
                "@type": type.googleapis.com/envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager
                stat_prefix: ingress_http
                codec_type: AUTO
                route_config:
                  name: local_route
                  virtual_hosts:
                    - name: backend
                      domains: ["*"]
                      routes:
                        - match: { prefix: "/" }
                          route:
                            cluster: backend_cluster
                            timeout: 0s
                http_filters:
                  - name: envoy.filters.http.lua
                    typed_config:
                      "@type": type.googleapis.com/envoy.extensions.filters.http.lua.v3.Lua
                      inline_code: |
                        -- Load the redis.lua script
                        package.path = "/etc/scripts/?.lua;" .. package.path

                        local redis = require 'redis'
                            
                          local params = {
                              host = 'redis',
                              port =  6379,
                          }
                            -- creating a global client
                          client = redis.connect(params)
                            
                            function envoy_on_request(request_handle)
                                -- Access the request path
                                request_path = request_handle:headers():get(":path")
                                request_handle:logInfo("Received request for path: " .. tostring(request_path)) 

                                -- check for cache
                                  local cached_response = client:get(request_path)  

                                      if cached_response then
                                          request_handle:logInfo("Found saved response for path: " .. tostring(request_path))
                                          local ttl = client:ttl(request_path)
                                          local cached_date_header = client:get(request_path .. "_date")
                                                  -- Respond with the cached response
                                                    request_handle:respond(
                                                      {
                                                        [":status"] = "200",
                                                        ["content-type"] = "application/json; charset=UTF-8",
                                                        ["Cache-TTL"] = tostring(ttl),
                                                        ["Date-generated"] = cached_date_header
                                                        
                                                      },
                                                       cached_response
                                                    )
                                                -- Stop requesting backend
                                                request_handle:logInfo("Responded with cached response")
                                          
                                      else
                                          request_handle:logInfo("No Saved response for path: " .. tostring(request_path))
                                         
                                      end                                                                 

                             end

                            function envoy_on_response(response_handle)
                                                            -- take the path as it is a global variable now
                              local response_path=request_path
                              local available_response = client:get(response_path)  

                                if available_response then
                                return
                                end
                              
                               local cache_control_header = response_handle:headers():get("Cache-Control")
                               response_handle:logInfo("cache control header from backend: " .. tostring(cache_control_header))

                            -- Set default TTL
                            local ttl = 60  -- Set TTL to 1 minute

                            
                            if cache_control_header then
                                
                                if cache_control_header:find("no%-store") then
                                    response_handle:logInfo("Caching won't be available")
                                    return
                                
                                elseif cache_control_header:find("public") then
                                    response_handle:logInfo("Caching for public header")
                                   
                                    local max_age = cache_control_header:match("max%-age=(%d+)")
                                    response_handle:logInfo("Cache TTL from max-age: " .. tostring(max_age))
                                    if max_age then
                                        ttl = tonumber(max_age)
                                    end
                                end
                            else
                                -- Cache-Control header is not present
                                response_handle:logInfo("Cache-Control headers are not present")
                            end

                            
                            response_handle:logInfo("Using TTL for caching: " .. tostring(ttl))


                                                      
                              response_handle:logInfo("inside the response path")
                              local response_body = response_handle:body()
                              -- need th below syntax for taking a string
                              local response = tostring(response_body:getBytes(0, response_body:length()))
                              local response_size = response_handle:body():length()
                              
                              response_handle:logInfo("Extracted the body " .. tostring(response_size))
                              response_handle:logInfo("Extracted the body: " .. tostring(response))


                              -- save the response taking the path as the key value
                                
                                client:select(15) -- for test
                                -- client:set(response_path, response)
                                    
                                    client:setex(response_path, ttl, response)

                                    local date_header = response_handle:headers():get("Date")
                                      if date_header then
                                          client:set(response_path .. "_date", date_header)
                                      end

                                local value = client:get(response_path)

                                -- print(value)
                                response_handle:logInfo("Saved response for path: " .. tostring(value))

                             end
 
                  - name: envoy.filters.http.router
                    typed_config:
                      "@type": type.googleapis.com/envoy.extensions.filters.http.router.v3.Router
  clusters:
    - name: backend_cluster
      connect_timeout: 0.25s
      type: STRICT_DNS
      lb_policy: round_robin
      load_assignment:
        cluster_name: backend_cluster
        endpoints:
          - lb_endpoints:
              - endpoint:
                  address:
                    socket_address:
                      address: new_go_backend
                      port_value: 8000
